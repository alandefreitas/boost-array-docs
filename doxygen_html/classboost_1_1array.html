<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Array: boost::array&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Array
   </div>
   <div id="projectbrief">Boost.Array Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="classboost_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classboost_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">boost::array&lt; T, N &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A container that encapsulates fixed size arrays.  
 <a href="classboost_1_1array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Types</div></td></tr>
<tr class="memitem:a022187b46857a02101625dd81bf6316b"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a022187b46857a02101625dd81bf6316b">value_type</a></td></tr>
<tr class="memdesc:a022187b46857a02101625dd81bf6316b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array value type.  <a href="classboost_1_1array.html#a022187b46857a02101625dd81bf6316b">More...</a><br /></td></tr>
<tr class="separator:a022187b46857a02101625dd81bf6316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb592501d52dd0f5f089711322ea803"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a></td></tr>
<tr class="memdesc:a8fb592501d52dd0f5f089711322ea803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to C-style array, i.e. a pointer.  <a href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">More...</a><br /></td></tr>
<tr class="separator:a8fb592501d52dd0f5f089711322ea803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9008295fb3d185c6c421b74508014d9e"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a></td></tr>
<tr class="memdesc:a9008295fb3d185c6c421b74508014d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator to array, i.e. a pointer.  <a href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">More...</a><br /></td></tr>
<tr class="separator:a9008295fb3d185c6c421b74508014d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1f6643db2ae1f3a5d44b25e4846d4"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a></td></tr>
<tr class="memdesc:aede1f6643db2ae1f3a5d44b25e4846d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to value type.  <a href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">More...</a><br /></td></tr>
<tr class="separator:aede1f6643db2ae1f3a5d44b25e4846d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7687abe63a9bd834d526814424f670ad"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a></td></tr>
<tr class="memdesc:a7687abe63a9bd834d526814424f670ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reference to value type.  <a href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">More...</a><br /></td></tr>
<tr class="separator:a7687abe63a9bd834d526814424f670ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e629bd53fa9a083afff4caea10126"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a></td></tr>
<tr class="memdesc:a2e2e629bd53fa9a083afff4caea10126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent array size.  <a href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">More...</a><br /></td></tr>
<tr class="separator:a2e2e629bd53fa9a083afff4caea10126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30bfc655383f5d40dce586585cfe5a6"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ac30bfc655383f5d40dce586585cfe5a6">difference_type</a></td></tr>
<tr class="memdesc:ac30bfc655383f5d40dce586585cfe5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent distance between iterators.  <a href="classboost_1_1array.html#ac30bfc655383f5d40dce586585cfe5a6">More...</a><br /></td></tr>
<tr class="separator:ac30bfc655383f5d40dce586585cfe5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86678e7a82440cbb56492f6cff28e6a"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">reverse_iterator</a></td></tr>
<tr class="memdesc:aa86678e7a82440cbb56492f6cff28e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse array iterator - std::reverse_iterator&lt;iterator&gt;  <a href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">More...</a><br /></td></tr>
<tr class="separator:aa86678e7a82440cbb56492f6cff28e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59bce7e02928b849675afbda442529b"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab59bce7e02928b849675afbda442529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse array iterator - std::reverse_iterator&lt;const_iterator&gt;  <a href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">More...</a><br /></td></tr>
<tr class="separator:ab59bce7e02928b849675afbda442529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a692b0cab4e768f391c6784c799ea61ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a> ()</td></tr>
<tr class="memdesc:a692b0cab4e768f391c6784c799ea61ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">More...</a><br /></td></tr>
<tr class="separator:a692b0cab4e768f391c6784c799ea61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95f0440a65f5c83ed5d856fd178e6aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ab95f0440a65f5c83ed5d856fd178e6aa">begin</a> () const</td></tr>
<tr class="memdesc:ab95f0440a65f5c83ed5d856fd178e6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the beginning.  <a href="classboost_1_1array.html#ab95f0440a65f5c83ed5d856fd178e6aa">More...</a><br /></td></tr>
<tr class="separator:ab95f0440a65f5c83ed5d856fd178e6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae444f246ca62c020a7bc0f704cd110c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ae444f246ca62c020a7bc0f704cd110c6">cbegin</a> () const</td></tr>
<tr class="memdesc:ae444f246ca62c020a7bc0f704cd110c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the beginning.  <a href="classboost_1_1array.html#ae444f246ca62c020a7bc0f704cd110c6">More...</a><br /></td></tr>
<tr class="separator:ae444f246ca62c020a7bc0f704cd110c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceca2d1f87a5832e13db810b75b7a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> ()</td></tr>
<tr class="memdesc:a7ceca2d1f87a5832e13db810b75b7a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">More...</a><br /></td></tr>
<tr class="separator:a7ceca2d1f87a5832e13db810b75b7a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1ab257306210dc1de06fc4e169d4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#aac1ab257306210dc1de06fc4e169d4c2">end</a> () const</td></tr>
<tr class="memdesc:aac1ab257306210dc1de06fc4e169d4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end.  <a href="classboost_1_1array.html#aac1ab257306210dc1de06fc4e169d4c2">More...</a><br /></td></tr>
<tr class="separator:aac1ab257306210dc1de06fc4e169d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace68c34d0dda5076465eae95e2a53697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ace68c34d0dda5076465eae95e2a53697">cend</a> () const</td></tr>
<tr class="memdesc:ace68c34d0dda5076465eae95e2a53697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end.  <a href="classboost_1_1array.html#ace68c34d0dda5076465eae95e2a53697">More...</a><br /></td></tr>
<tr class="separator:ace68c34d0dda5076465eae95e2a53697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9885b0aeb526f689af81a6bdacf9ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a1f9885b0aeb526f689af81a6bdacf9ac">rbegin</a> ()</td></tr>
<tr class="memdesc:a1f9885b0aeb526f689af81a6bdacf9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="classboost_1_1array.html#a1f9885b0aeb526f689af81a6bdacf9ac">More...</a><br /></td></tr>
<tr class="separator:a1f9885b0aeb526f689af81a6bdacf9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b9841cd058a638db4146bb5c559245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a27b9841cd058a638db4146bb5c559245">rbegin</a> () const</td></tr>
<tr class="memdesc:a27b9841cd058a638db4146bb5c559245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the beginning.  <a href="classboost_1_1array.html#a27b9841cd058a638db4146bb5c559245">More...</a><br /></td></tr>
<tr class="separator:a27b9841cd058a638db4146bb5c559245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9015cb9e0b2d715f196d8320c9caff7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a9015cb9e0b2d715f196d8320c9caff7b">crbegin</a> () const</td></tr>
<tr class="memdesc:a9015cb9e0b2d715f196d8320c9caff7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="classboost_1_1array.html#a9015cb9e0b2d715f196d8320c9caff7b">More...</a><br /></td></tr>
<tr class="separator:a9015cb9e0b2d715f196d8320c9caff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b762d7319eef06c90f23c4b23a61da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> ()</td></tr>
<tr class="memdesc:a33b762d7319eef06c90f23c4b23a61da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">More...</a><br /></td></tr>
<tr class="separator:a33b762d7319eef06c90f23c4b23a61da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c7a198622ace353cde3a72e89c9313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a13c7a198622ace353cde3a72e89c9313">rend</a> () const</td></tr>
<tr class="memdesc:a13c7a198622ace353cde3a72e89c9313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the end.  <a href="classboost_1_1array.html#a13c7a198622ace353cde3a72e89c9313">More...</a><br /></td></tr>
<tr class="separator:a13c7a198622ace353cde3a72e89c9313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780d872842ec6cfadfde837985eec2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a780d872842ec6cfadfde837985eec2f2">crend</a> () const</td></tr>
<tr class="memdesc:a780d872842ec6cfadfde837985eec2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the end.  <a href="classboost_1_1array.html#a780d872842ec6cfadfde837985eec2f2">More...</a><br /></td></tr>
<tr class="separator:a780d872842ec6cfadfde837985eec2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr class="memitem:a74badfd510006ffbf312cc986c8f0422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a> (<a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> i)</td></tr>
<tr class="memdesc:a74badfd510006ffbf312cc986c8f0422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element.  <a href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">More...</a><br /></td></tr>
<tr class="separator:a74badfd510006ffbf312cc986c8f0422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c50e5384c7c5b1c974c2c2785b82681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a3c50e5384c7c5b1c974c2c2785b82681">operator[]</a> (<a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> i) const</td></tr>
<tr class="memdesc:a3c50e5384c7c5b1c974c2c2785b82681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element.  <a href="classboost_1_1array.html#a3c50e5384c7c5b1c974c2c2785b82681">More...</a><br /></td></tr>
<tr class="separator:a3c50e5384c7c5b1c974c2c2785b82681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1b3cebca2a48519d249809c6963e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a> (<a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> i)</td></tr>
<tr class="memdesc:ab1d1b3cebca2a48519d249809c6963e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">More...</a><br /></td></tr>
<tr class="separator:ab1d1b3cebca2a48519d249809c6963e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af5015ebee025ca5ae122b2aa52c3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a8af5015ebee025ca5ae122b2aa52c3b9">at</a> (<a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> i) const</td></tr>
<tr class="memdesc:a8af5015ebee025ca5ae122b2aa52c3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="classboost_1_1array.html#a8af5015ebee025ca5ae122b2aa52c3b9">More...</a><br /></td></tr>
<tr class="separator:a8af5015ebee025ca5ae122b2aa52c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1be3a887c18b970da977d58210d42c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a5f1be3a887c18b970da977d58210d42c">front</a> ()</td></tr>
<tr class="memdesc:a5f1be3a887c18b970da977d58210d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first array element.  <a href="classboost_1_1array.html#a5f1be3a887c18b970da977d58210d42c">More...</a><br /></td></tr>
<tr class="separator:a5f1be3a887c18b970da977d58210d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b39836ec93519b6d48f2fb87d3c238"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#af5b39836ec93519b6d48f2fb87d3c238">front</a> () const</td></tr>
<tr class="memdesc:af5b39836ec93519b6d48f2fb87d3c238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first array element.  <a href="classboost_1_1array.html#af5b39836ec93519b6d48f2fb87d3c238">More...</a><br /></td></tr>
<tr class="separator:af5b39836ec93519b6d48f2fb87d3c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac7c3e7833222573dc540ee5791df74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a1ac7c3e7833222573dc540ee5791df74">back</a> ()</td></tr>
<tr class="memdesc:a1ac7c3e7833222573dc540ee5791df74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last array element.  <a href="classboost_1_1array.html#a1ac7c3e7833222573dc540ee5791df74">More...</a><br /></td></tr>
<tr class="separator:a1ac7c3e7833222573dc540ee5791df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e23a8eb90852a11306a0561f91d632"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a19e23a8eb90852a11306a0561f91d632">back</a> () const</td></tr>
<tr class="memdesc:a19e23a8eb90852a11306a0561f91d632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last array element.  <a href="classboost_1_1array.html#a19e23a8eb90852a11306a0561f91d632">More...</a><br /></td></tr>
<tr class="separator:a19e23a8eb90852a11306a0561f91d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Swap</div></td></tr>
<tr class="memitem:a342ef866ed696b18ce803b5c9aba4b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a342ef866ed696b18ce803b5c9aba4b2e">swap</a> (<a class="el" href="classboost_1_1array.html">array</a>&lt; T, N &gt; &amp;y)</td></tr>
<tr class="memdesc:a342ef866ed696b18ce803b5c9aba4b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the container contents.  <a href="classboost_1_1array.html#a342ef866ed696b18ce803b5c9aba4b2e">More...</a><br /></td></tr>
<tr class="separator:a342ef866ed696b18ce803b5c9aba4b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Direct access to data</div></td></tr>
<tr class="memitem:a748e5ab084bbeb2538f91a28a602b0ef"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a748e5ab084bbeb2538f91a28a602b0ef">data</a> () const</td></tr>
<tr class="memdesc:a748e5ab084bbeb2538f91a28a602b0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying array.  <a href="classboost_1_1array.html#a748e5ab084bbeb2538f91a28a602b0ef">More...</a><br /></td></tr>
<tr class="separator:a748e5ab084bbeb2538f91a28a602b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6643955f9fe16d97251ab3d7a1d1d819"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a6643955f9fe16d97251ab3d7a1d1d819">data</a> ()</td></tr>
<tr class="memdesc:a6643955f9fe16d97251ab3d7a1d1d819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying array.  <a href="classboost_1_1array.html#a6643955f9fe16d97251ab3d7a1d1d819">More...</a><br /></td></tr>
<tr class="separator:a6643955f9fe16d97251ab3d7a1d1d819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbe1fd971304a5a17e62b7e322e68b5"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#afcbe1fd971304a5a17e62b7e322e68b5">c_array</a> ()</td></tr>
<tr class="memdesc:afcbe1fd971304a5a17e62b7e322e68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying array.  <a href="classboost_1_1array.html#afcbe1fd971304a5a17e62b7e322e68b5">More...</a><br /></td></tr>
<tr class="separator:afcbe1fd971304a5a17e62b7e322e68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment with type conversion</div></td></tr>
<tr class="memitem:aa739c62fa223d40701f32a90263d839b"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:aa739c62fa223d40701f32a90263d839b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#aa739c62fa223d40701f32a90263d839b">operator=</a> (const <a class="el" href="classboost_1_1array.html">array</a>&lt; T2, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa739c62fa223d40701f32a90263d839b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites element of the array with elements of another array.  <a href="classboost_1_1array.html#aa739c62fa223d40701f32a90263d839b">More...</a><br /></td></tr>
<tr class="separator:aa739c62fa223d40701f32a90263d839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df5174212f1ec0dbe3e01a685ad77e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a3df5174212f1ec0dbe3e01a685ad77e2">assign</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3df5174212f1ec0dbe3e01a685ad77e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign one value to all elements.  <a href="classboost_1_1array.html#a3df5174212f1ec0dbe3e01a685ad77e2">More...</a><br /></td></tr>
<tr class="separator:a3df5174212f1ec0dbe3e01a685ad77e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd92c3399a847641733637356b0c972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a4dd92c3399a847641733637356b0c972">fill</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4dd92c3399a847641733637356b0c972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign one value to all elements.  <a href="classboost_1_1array.html#a4dd92c3399a847641733637356b0c972">More...</a><br /></td></tr>
<tr class="separator:a4dd92c3399a847641733637356b0c972"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a09733031646cc6929dd2a7d6bcb02e50"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a> ()</td></tr>
<tr class="memdesc:a09733031646cc6929dd2a7d6bcb02e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements.  <a href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">More...</a><br /></td></tr>
<tr class="separator:a09733031646cc6929dd2a7d6bcb02e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5938420228bf47d1d3a51466dc06c882"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a5938420228bf47d1d3a51466dc06c882">empty</a> ()</td></tr>
<tr class="memdesc:a5938420228bf47d1d3a51466dc06c882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="classboost_1_1array.html#a5938420228bf47d1d3a51466dc06c882">More...</a><br /></td></tr>
<tr class="separator:a5938420228bf47d1d3a51466dc06c882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71e7cb18671cde0e27e2f45b0efdb13"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#ab71e7cb18671cde0e27e2f45b0efdb13">max_size</a> ()</td></tr>
<tr class="memdesc:ab71e7cb18671cde0e27e2f45b0efdb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible number of elements.  <a href="classboost_1_1array.html#ab71e7cb18671cde0e27e2f45b0efdb13">More...</a><br /></td></tr>
<tr class="separator:ab71e7cb18671cde0e27e2f45b0efdb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Check range</div></td></tr>
<tr class="memitem:a443e911da2845395d5a6cba45daa5fba"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a443e911da2845395d5a6cba45daa5fba">rangecheck</a> (<a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> i)</td></tr>
<tr class="memdesc:a443e911da2845395d5a6cba45daa5fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check range.  <a href="classboost_1_1array.html#a443e911da2845395d5a6cba45daa5fba">More...</a><br /></td></tr>
<tr class="separator:a443e911da2845395d5a6cba45daa5fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a03bab5772c1f84688e9fafc35275eef7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1array.html#a03bab5772c1f84688e9fafc35275eef7">elems</a> [N]</td></tr>
<tr class="memdesc:a03bab5772c1f84688e9fafc35275eef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying fixed-size array of elements of type T.  <a href="classboost_1_1array.html#a03bab5772c1f84688e9fafc35275eef7">More...</a><br /></td></tr>
<tr class="separator:a03bab5772c1f84688e9fafc35275eef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, std::size_t N&gt;<br />
class boost::array&lt; T, N &gt;</div><p >A container that encapsulates fixed size arrays. </p>
<p >This class represents a container that encapsulates fixed size arrays.</p>
<p >It has the same semantics as a struct holding a C-style array <code>T[N]</code>. Unlike a C-style array, it doesn't decay to T* automatically.</p>
<p >The class combines the performance of a C-style array with the convenience of a standard container.</p>
<p >There is a special case for a zero-length array (N == 0). In that case, array.begin() == array.end(), which is some unique value.</p>
<dl class="section user"><dt>Thread Safety</dt><dd></dd></dl>
<p>Not thread safe</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array value type </td></tr>
    <tr><td class="paramname">N</td><td>The array size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also std::vector </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9008295fb3d185c6c421b74508014d9e" name="a9008295fb3d185c6c421b74508014d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9008295fb3d185c6c421b74508014d9e">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant iterator to array, i.e. a pointer. </p>

</div>
</div>
<a id="a7687abe63a9bd834d526814424f670ad" name="a7687abe63a9bd834d526814424f670ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7687abe63a9bd834d526814424f670ad">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant reference to value type. </p>

</div>
</div>
<a id="ab59bce7e02928b849675afbda442529b" name="ab59bce7e02928b849675afbda442529b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59bce7e02928b849675afbda442529b">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a>&gt; <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant reverse array iterator - std::reverse_iterator&lt;const_iterator&gt; </p>

</div>
</div>
<a id="ac30bfc655383f5d40dce586585cfe5a6" name="ac30bfc655383f5d40dce586585cfe5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30bfc655383f5d40dce586585cfe5a6">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#ac30bfc655383f5d40dce586585cfe5a6">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to represent distance between iterators. </p>

</div>
</div>
<a id="a8fb592501d52dd0f5f089711322ea803" name="a8fb592501d52dd0f5f089711322ea803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb592501d52dd0f5f089711322ea803">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator to C-style array, i.e. a pointer. </p>

</div>
</div>
<a id="aede1f6643db2ae1f3a5d44b25e4846d4" name="aede1f6643db2ae1f3a5d44b25e4846d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1f6643db2ae1f3a5d44b25e4846d4">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to value type. </p>

</div>
</div>
<a id="aa86678e7a82440cbb56492f6cff28e6a" name="aa86678e7a82440cbb56492f6cff28e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86678e7a82440cbb56492f6cff28e6a">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a>&gt; <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse array iterator - std::reverse_iterator&lt;iterator&gt; </p>

</div>
</div>
<a id="a2e2e629bd53fa9a083afff4caea10126" name="a2e2e629bd53fa9a083afff4caea10126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2e629bd53fa9a083afff4caea10126">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to represent array size. </p>

</div>
</div>
<a id="a022187b46857a02101625dd81bf6316b" name="a022187b46857a02101625dd81bf6316b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022187b46857a02101625dd81bf6316b">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::<a class="el" href="classboost_1_1array.html#a022187b46857a02101625dd81bf6316b">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The array value type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3df5174212f1ec0dbe3e01a685ad77e2" name="a3df5174212f1ec0dbe3e01a685ad77e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df5174212f1ec0dbe3e01a685ad77e2">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign one value to all elements. </p>
<p >This function assigns the same value to all arrays elements</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Linear</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function is not available in <code>std::array</code>.</p>
<p >This function is a synonym for <a class="el" href="classboost_1_1array.html#a4dd92c3399a847641733637356b0c972">fill</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>(none)</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#aa739c62fa223d40701f32a90263d839b">operator=</a>, <a class="el" href="classboost_1_1array.html#a4dd92c3399a847641733637356b0c972">fill</a> </p>

</div>
</div>
<a id="ab1d1b3cebca2a48519d249809c6963e5" name="ab1d1b3cebca2a48519d249809c6963e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1b3cebca2a48519d249809c6963e5">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access specified element with bounds checking. </p>
<p >This function Returns a reference to the element at specified location i, with bounds checking.</p>
<p >If pos is not within the range of the container, an exception of type <code>std::out_of_range</code> is thrown.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(i &lt; size())</p>
<dl class="section user"><dt>Exception Safety</dt><dd></dd></dl>
<p><code>std::out_of_range</code> if !(i &lt; size()).</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a> </p>

</div>
</div>
<a id="a8af5015ebee025ca5ae122b2aa52c3b9" name="a8af5015ebee025ca5ae122b2aa52c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af5015ebee025ca5ae122b2aa52c3b9">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access specified element with bounds checking. </p>
<p >This function Returns a reference to the element at specified location i, with bounds checking.</p>
<p >If pos is not within the range of the container, an exception of type <code>std::out_of_range</code> is thrown.</p>
<p >This overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(i &lt; size())</p>
<dl class="section user"><dt>Exception Safety</dt><dd></dd></dl>
<p><code>std::out_of_range</code> if !(i &lt; size()).</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a> </p>

</div>
</div>
<a id="a1ac7c3e7833222573dc540ee5791df74" name="a1ac7c3e7833222573dc540ee5791df74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac7c3e7833222573dc540ee5791df74">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last array element. </p>
<p >This function returns a reference to the last element in the container.</p>
<p >Calling front on an empty container is undefined.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><code>c.back()</code> is equivalent to <code>*stdprev(c.end())</code></p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(empty())</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last array element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a>, <a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a>, <a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a>, <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="a19e23a8eb90852a11306a0561f91d632" name="a19e23a8eb90852a11306a0561f91d632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e23a8eb90852a11306a0561f91d632">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last array element. </p>
<p >This function returns a reference to the last element in the container.</p>
<p >Calling front on an empty container is undefined.</p>
<p >This overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><code>c.back()</code> is equivalent to <code>*stdprev(c.end())</code></p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(empty())</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last array element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a>, <a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a>, <a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a>, <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="a692b0cab4e768f391c6784c799ea61ab" name="a692b0cab4e768f391c6784c799ea61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692b0cab4e768f391c6784c799ea61ab">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p >This function returns an iterator to the first element of the array.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator will be equal to end()</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="ab95f0440a65f5c83ed5d856fd178e6aa" name="ab95f0440a65f5c83ed5d856fd178e6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95f0440a65f5c83ed5d856fd178e6aa">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the beginning. </p>
<p >This function returns a constant iterator to the first element of the array. This is the overload that gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator will be equal to end()</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="afcbe1fd971304a5a17e62b7e322e68b5" name="afcbe1fd971304a5a17e62b7e322e68b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbe1fd971304a5a17e62b7e322e68b5">&#9670;&nbsp;</a></span>c_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::c_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the underlying array. </p>
<p >Returns pointer to the underlying array serving as element storage.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The pointer is such that range [data(); data() + size()) is always a valid range, even if the container is empty.</p>
<p >When the container is empty, data() is not dereferenceable.</p>
<p >If size() is 0, data() may or may not return a null pointer.</p>
<p >This function is not available in <code>std::array</code></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage</dd></dl>
<p>For non-empty containers, the returned pointer compares equal to the address of the first element.</p>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a5f1be3a887c18b970da977d58210d42c">front</a>, <a class="el" href="classboost_1_1array.html#a1ac7c3e7833222573dc540ee5791df74">back</a>, <a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a> </p>

</div>
</div>
<a id="ae444f246ca62c020a7bc0f704cd110c6" name="ae444f246ca62c020a7bc0f704cd110c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae444f246ca62c020a7bc0f704cd110c6">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the beginning. </p>
<p >This function returns a constant iterator to the first element of the array.</p>
<p >This function is usually called to provide a constant iterator when <code>this</code> is not constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator will be equal to end() </p><pre class="fragment">@return Iterator to the first element of the array
</pre> <dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="ace68c34d0dda5076465eae95e2a53697" name="ace68c34d0dda5076465eae95e2a53697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace68c34d0dda5076465eae95e2a53697">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end. </p>
<p >This function returns a constant iterator to the element following the last element of the array.</p>
<p >This function is usually called to provide a constant iterator when <code>this</code> is not constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator will be equal to end()</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element of the array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#ae444f246ca62c020a7bc0f704cd110c6">cbegin</a> </p>

</div>
</div>
<a id="a9015cb9e0b2d715f196d8320c9caff7b" name="a9015cb9e0b2d715f196d8320c9caff7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9015cb9e0b2d715f196d8320c9caff7b">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p >Returns a reverse iterator to the first element of the reversed array.</p>
<p >This reverse iterator corresponds to the last element of the non-reversed array.</p>
<p >This function is usually called to provide a constant iterator when <code>this</code> is not constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator is equal to rend().</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element of the reversed array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> </p>

</div>
</div>
<a id="a780d872842ec6cfadfde837985eec2f2" name="a780d872842ec6cfadfde837985eec2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780d872842ec6cfadfde837985eec2f2">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the end. </p>
<p >Returns a reverse iterator to the element following the last element of the reversed array.</p>
<p >This iterator corresponds to the element preceding the first element of the non-reversed array.</p>
<p >This element acts as a placeholder. Attempting to access it results in undefined behavior.</p>
<p >This function is usually called to provide a constant iterator when <code>this</code> is not constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator is equal to rend().</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element of the reversed array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> </p>

</div>
</div>
<a id="a6643955f9fe16d97251ab3d7a1d1d819" name="a6643955f9fe16d97251ab3d7a1d1d819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6643955f9fe16d97251ab3d7a1d1d819">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the underlying array. </p>
<p >Returns pointer to the underlying array serving as element storage.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The pointer is such that range [data(); data() + size()) is always a valid range, even if the container is empty.</p>
<p >When the container is empty, data() is not dereferenceable.</p>
<p >If size() is 0, data() may or may not return a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage</dd></dl>
<p>For non-empty containers, the returned pointer compares equal to the address of the first element.</p>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a5f1be3a887c18b970da977d58210d42c">front</a>, <a class="el" href="classboost_1_1array.html#a1ac7c3e7833222573dc540ee5791df74">back</a>, <a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a> </p>

</div>
</div>
<a id="a748e5ab084bbeb2538f91a28a602b0ef" name="a748e5ab084bbeb2538f91a28a602b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748e5ab084bbeb2538f91a28a602b0ef">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the underlying array. </p>
<p >Returns pointer to the underlying array serving as element storage.</p>
<p >This overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The pointer is such that range [data(); data() + size()) is always a valid range, even if the container is empty.</p>
<p >When the container is empty, data() is not dereferenceable.</p>
<p >If size() is 0, data() may or may not return a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage</dd></dl>
<p>For non-empty containers, the returned pointer compares equal to the address of the first element.</p>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a5f1be3a887c18b970da977d58210d42c">front</a>, <a class="el" href="classboost_1_1array.html#a1ac7c3e7833222573dc540ee5791df74">back</a>, <a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a> </p>

</div>
</div>
<a id="a5938420228bf47d1d3a51466dc06c882" name="a5938420228bf47d1d3a51466dc06c882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5938420228bf47d1d3a51466dc06c882">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<p >This function checks whether the container is empty</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><code>empty()</code> is equivalent to <code>begin() == end()</code></p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty, <code>false</code> otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a>, <a class="el" href="classboost_1_1array.html#ab71e7cb18671cde0e27e2f45b0efdb13">max_size</a> </p>

</div>
</div>
<a id="a7ceca2d1f87a5832e13db810b75b7a20" name="a7ceca2d1f87a5832e13db810b75b7a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceca2d1f87a5832e13db810b75b7a20">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a8fb592501d52dd0f5f089711322ea803">iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<p >This function returns an iterator to the element following the last element of the array</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator will be equal to end()</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element of the array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a> </p>

</div>
</div>
<a id="aac1ab257306210dc1de06fc4e169d4c2" name="aac1ab257306210dc1de06fc4e169d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1ab257306210dc1de06fc4e169d4c2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a9008295fb3d185c6c421b74508014d9e">const_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end. </p>
<p >This function returns a constant iterator to the first element of the array.</p>
<p >This function overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator will be equal to end()</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element of the array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a> </p>

</div>
</div>
<a id="a4dd92c3399a847641733637356b0c972" name="a4dd92c3399a847641733637356b0c972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd92c3399a847641733637356b0c972">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign one value to all elements. </p>
<p >This function assigns the same value to all arrays elements</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Linear</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function is not available in <code>std::array</code></p>
<dl class="section return"><dt>Returns</dt><dd>(none)</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#aa739c62fa223d40701f32a90263d839b">operator=</a> </p>

</div>
</div>
<a id="a5f1be3a887c18b970da977d58210d42c" name="a5f1be3a887c18b970da977d58210d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1be3a887c18b970da977d58210d42c">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first array element. </p>
<p >This function returns a reference to the first element in the container.</p>
<p >Calling front on an empty container is undefined.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><code>c.front()</code> is equivalent to <code>*c.begin()</code></p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(empty())</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first array element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a>, <a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a>, <a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a>, <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="af5b39836ec93519b6d48f2fb87d3c238" name="af5b39836ec93519b6d48f2fb87d3c238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b39836ec93519b6d48f2fb87d3c238">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first array element. </p>
<p >This function returns a reference to the first element in the container.</p>
<p >Calling front on an empty container is undefined.</p>
<p >This overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><code>c.front()</code> is equivalent to <code>*c.begin()</code></p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(empty())</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first array element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a74badfd510006ffbf312cc986c8f0422">operator[]</a>, <a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a>, <a class="el" href="classboost_1_1array.html#a692b0cab4e768f391c6784c799ea61ab">begin</a>, <a class="el" href="classboost_1_1array.html#a7ceca2d1f87a5832e13db810b75b7a20">end</a> </p>

</div>
</div>
<a id="ab71e7cb18671cde0e27e2f45b0efdb13" name="ab71e7cb18671cde0e27e2f45b0efdb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71e7cb18671cde0e27e2f45b0efdb13">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible number of elements. </p>
<p >Returns the maximum number of elements the container is able to hold due to system or library implementation limitations</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Because array&lt;T, N&gt; is a fixed-size container, the value returned by <code>max_size()</code> is equivalent to <code>size()</code></p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a>, <a class="el" href="classboost_1_1array.html#a5938420228bf47d1d3a51466dc06c882">empty</a> </p>

</div>
</div>
<a id="aa739c62fa223d40701f32a90263d839b" name="aa739c62fa223d40701f32a90263d839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa739c62fa223d40701f32a90263d839b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html">array</a>&lt; T, N &gt; &amp; <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1array.html">array</a>&lt; T2, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites element of the array with elements of another array. </p>
<p >This function overwrites every element of the this array with the corresponding elements of another array</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Linear</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>this</code> array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a3df5174212f1ec0dbe3e01a685ad77e2">assign</a> </p>

</div>
</div>
<a id="a74badfd510006ffbf312cc986c8f0422" name="a74badfd510006ffbf312cc986c8f0422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74badfd510006ffbf312cc986c8f0422">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#aede1f6643db2ae1f3a5d44b25e4846d4">reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access specified element. </p>
<p >This function Returns a reference to the element at specified location i.</p>
<p >No bounds checking is performed.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(i &lt; size())</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Unlike std::map::operator[], this operator never inserts a new element into the container.</p>
<p >Accessing a nonexistent element through this operator is undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a> </p>

</div>
</div>
<a id="a3c50e5384c7c5b1c974c2c2785b82681" name="a3c50e5384c7c5b1c974c2c2785b82681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c50e5384c7c5b1c974c2c2785b82681">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#a7687abe63a9bd834d526814424f670ad">const_reference</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access specified element. </p>
<p >This function Returns a reference to the element at specified location i.</p>
<p >No bounds checking is performed.</p>
<p >This overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section user"><dt>Preconditions</dt><dd></dd></dl>
<p>!(i &lt; size())</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Unlike std::map::operator[], this operator never inserts a new element into the container.</p>
<p >Accessing a nonexistent element through this operator is undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#ab1d1b3cebca2a48519d249809c6963e5">at</a> </p>

</div>
</div>
<a id="a443e911da2845395d5a6cba45daa5fba" name="a443e911da2845395d5a6cba45daa5fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443e911da2845395d5a6cba45daa5fba">&#9670;&nbsp;</a></span>rangecheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::rangecheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check range. </p>
<p >This function checks if i in the valid range for the array.</p>
<p >This function may be private because it is static.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section user"><dt>Exception Safety</dt><dd></dd></dl>
<p>Throws <code>std::out_of_range</code> if i is not in the valid range.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function is not available in <code>std::array</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if i is in the valid range for the array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a09733031646cc6929dd2a7d6bcb02e50">size</a>, <a class="el" href="classboost_1_1array.html#a5938420228bf47d1d3a51466dc06c882">empty</a> </p>

</div>
</div>
<a id="a1f9885b0aeb526f689af81a6bdacf9ac" name="a1f9885b0aeb526f689af81a6bdacf9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9885b0aeb526f689af81a6bdacf9ac">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">reverse_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p >Returns a reverse iterator to the first element of the reversed array.</p>
<p >This reverse iterator corresponds to the last element of the non-reversed array.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator is equal to rend().</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element of the reversed array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> </p>

</div>
</div>
<a id="a27b9841cd058a638db4146bb5c559245" name="a27b9841cd058a638db4146bb5c559245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b9841cd058a638db4146bb5c559245">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the beginning. </p>
<p >Returns a reverse iterator to the first element of the reversed array.</p>
<p >This reverse iterator corresponds to the last element of the non-reversed array.</p>
<p >This function overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator is equal to rend().</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element of the reversed array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> </p>

</div>
</div>
<a id="a33b762d7319eef06c90f23c4b23a61da" name="a33b762d7319eef06c90f23c4b23a61da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b762d7319eef06c90f23c4b23a61da">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#aa86678e7a82440cbb56492f6cff28e6a">reverse_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<p >Returns a reverse iterator to the element following the last element of the reversed array.</p>
<p >This iterator corresponds to the element preceding the first element of the non-reversed array.</p>
<p >This element acts as a placeholder. Attempting to access it results in undefined behavior.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator is equal to rend().</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element of the reversed array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> </p>

</div>
</div>
<a id="a13c7a198622ace353cde3a72e89c9313" name="a13c7a198622ace353cde3a72e89c9313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c7a198622ace353cde3a72e89c9313">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1array.html#ab59bce7e02928b849675afbda442529b">const_reverse_iterator</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the end. </p>
<p >Returns a reverse iterator to the element following the last element of the reversed array.</p>
<p >This iterator corresponds to the element preceding the first element of the non-reversed array.</p>
<p >This element acts as a placeholder. Attempting to access it results in undefined behavior.</p>
<p >This function overload gets called when <code>this</code> is constant.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the array is empty, the returned iterator is equal to rend().</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element of the reversed array</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a33b762d7319eef06c90f23c4b23a61da">rend</a> </p>

</div>
</div>
<a id="a09733031646cc6929dd2a7d6bcb02e50" name="a09733031646cc6929dd2a7d6bcb02e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09733031646cc6929dd2a7d6bcb02e50">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classboost_1_1array.html#a2e2e629bd53fa9a083afff4caea10126">size_type</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements. </p>
<p >This function returns the number of elements in the container.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Constant</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><code>size()</code> is equivalent to <code>std::distance(begin(), end())</code></p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a5938420228bf47d1d3a51466dc06c882">empty</a>, <a class="el" href="classboost_1_1array.html#ab71e7cb18671cde0e27e2f45b0efdb13">max_size</a> </p>

</div>
</div>
<a id="a342ef866ed696b18ce803b5c9aba4b2e" name="a342ef866ed696b18ce803b5c9aba4b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342ef866ed696b18ce803b5c9aba4b2e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the container contents. </p>
<p >Exchanges the contents of the container with those of other.</p>
<p >This function does not cause iterators and references to associate with the other container.</p>
<dl class="section user"><dt>Complexity</dt><dd></dd></dl>
<p>Linear</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Because array&lt;T, N&gt; is not dynamically allocated, this operation has linear complexity.</p>
<dl class="section return"><dt>Returns</dt><dd>(none)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>container to exchange the contents with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See Also <a class="el" href="classboost_1_1array.html#a4dd92c3399a847641733637356b0c972">fill</a>, <code>std::swap</code> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a03bab5772c1f84688e9fafc35275eef7" name="a03bab5772c1f84688e9fafc35275eef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bab5772c1f84688e9fafc35275eef7">&#9670;&nbsp;</a></span>elems</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; T, N &gt;::elems[N]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying fixed-size array of elements of type T. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
